{% macro toLuaTable(name, struct) %}
    void {{ name }}::toLuaTable(sol::table &table) const {
        {% for field in struct %}
            {
                auto ref = table["{{ field.name }}"];
                lua_converter<{{ field.typ }}>::toLua(ref, this->{{ field.name }});
            };
        {% endfor %}
    }
{% endmacro %}

{% macro fromLuaTable(name, splits) %}
    void {{ name }}::fromLuaTable(const sol::table &table) {
        {% if splits.mode != 'empty' %}
            for (const auto &[key, value] : table) {
                #ifndef NDEBUG
                    if (!key.is<std::string>())
                        throw gu_err("All keys in the table must be a string!");
                #endif

                {% if splits.mode != 'singleton' and splits.mode != 'empty' %}
                auto name = key.as<std::string>();
                {% endif %}

                {{ createSplit(splits) }}
            }
        {% endif %}
    }
{% endmacro %}

{% macro createSplit(splits) %}
    {% if splits.mode == 'singleton' %}
        #ifndef NDEBUG
        if (key.as<std::string>() != "{{ splits.value.name }}")
            throw gu_err("Name not in table: " + key.as<std::string>() + ", did you mean {{ splits.value.name }}?");
        #endif
        lua_converter<{{ splits.value.typ }}>::fromLua(value, this->{{ splits.value.name }});
    {% elif splits.mode == 'length' %}
        switch (name.length()) {
            {{ splitCases(splits.buckets) }}
            {{ switchDefault() }}
        }
    {% elif splits.mode == 'letter' %}
        switch (name[{{ splits.index}}]) {
            {{ splitCases(splits.buckets) }}
            {{ switchDefault() }}
        }
    {% endif %}
{% endmacro %}

{% macro splitCases(cases) %}
    {% for case in cases %}
        case {{ case.key }}:
            {{ createSplit(case) }}
            break;
    {% endfor %}
{% endmacro %}

{% macro switchDefault() %}
    #ifndef NDEBUG
    default:
        throw gu_err("Name not in table: " + name);
        break;
    #endif
{% endmacro %}


{% macro generateLuaUserType(structName, struct) %}

    void {{ structName }}::generateLuaUserType(sol::state &lua)
    {
        sol::usertype<{{ structName }}> luaUserType = lua.new_usertype<{{ structName }}>("{{ structName }}"

        {% if struct.flags.not_a_component == False %}
                , sol::constructors<{{ structName }}(), {{ structName }}(const sol::table &)>()
        {% endif %}

        );

        {% for field in struct.expose %}
            luaUserType["{{ field.name }}"] = &{{ structName }}::{{ field.name }};
        {% endfor %}
    }

{% endmacro %}

{% macro registerEntityEngineFunctions(structName, struct) %}

void {{ structName }}::registerEntityEngineFunctions(sol::table &table, entt::registry &reg)
{
    auto utilsTable = table["{{ structName }}"].get_or_create<sol::table>();

    utilsTable["getFor"] = [&] (int entity) -> {{ structName }} * {

        {% if not struct.expose %} // struct.expose is empty

            throw gu_err("{{ structName }} is an empty struct thus cannot be returned.");

        {% else %}

            return &reg.get_or_assign<{{ structName }}>(entt::entity(entity));

        {% endif %}
    };
    utilsTable["has"] = [&] (int entity) -> bool {
        return reg.has<{{ structName }}>(entt::entity(entity));
    };
    utilsTable["remove"] = [&] (int entity) {
        reg.remove_if_exists<{{ structName }}>(entt::entity(entity));
    };
}

{% endmacro %}
